\chapter{System Design and Architecture}
\label{chap:design}

This chapter presents the design of our automatic cloud resource brokerage system for Kubernetes. We describe the overall architecture, component interactions, data models, and key design decisions.

\section{System Overview}
\label{sec:system-overview}

\subsection{Design Goals}

The system is designed with the following goals:

\begin{enumerate}
    \item \textbf{Kubernetes-Native}: Seamless integration with Kubernetes ecosystem using standard patterns (operators, CRDs, RBAC)

    \item \textbf{Scalability}: Support hundreds of managed clusters with minimal overhead

    \item \textbf{Reliability}: Handle failures gracefully with proper retry mechanisms and error recovery

    \item \textbf{Correctness}: Prevent race conditions and ensure consistent resource accounting

    \item \textbf{Extensibility}: Allow easy addition of new scoring criteria and decision logic

    \item \textbf{Performance}: Minimize latency in placement decisions and resource monitoring

    \item \textbf{Simplicity}: Keep the architecture straightforward and maintainable
\end{enumerate}

\subsection{High-Level Architecture}

The system consists of two main components deployed across a multi-cluster environment:

\begin{itemize}
    \item \textbf{Resource Agent (RA)}: Deployed on each managed cluster, monitors resources and publishes advertisements

    \item \textbf{Resource Broker (RB)}: Centralized component that receives advertisements and manages reservations
\end{itemize}

% TODO: Create and add architecture diagram
\begin{figure}[ht]
    \centering
    % TODO: Create comprehensive architecture diagram showing:
    % - Multiple clusters with Resource Agents
    % - Central Resource Broker
    % - Communication flows
    % - CRD resources
    % \includegraphics[width=\textwidth]{figures/system-architecture.pdf}
    \caption{System architecture showing Resource Agents on managed clusters communicating with centralized Resource Broker}
    \label{fig:system-architecture}
\end{figure}

\subsection{Deployment Model}

\paragraph{Resource Agent Deployment}
Each managed cluster runs one Resource Agent instance:
\begin{itemize}
    \item Deployed as a Kubernetes Deployment with single replica
    \item Requires cluster-wide read permissions for nodes and pods
    \item Requires write permissions for Advertisement CRD in local namespace
    \item Configured with broker endpoint URL and credentials
\end{itemize}

\paragraph{Resource Broker Deployment}
The broker runs in a dedicated "broker cluster":
\begin{itemize}
    \item Deployed as a Kubernetes Deployment (can scale for HA)
    \item Manages ClusterAdvertisement and Reservation CRDs
    \item Exposes API for Resource Agents to publish advertisements
    \item No direct access needed to managed cluster API servers
\end{itemize}

\section{Custom Resource Definitions}
\label{sec:crd-design}

\subsection{Advertisement CRD (Resource Agent)}

The Advertisement resource represents a local cluster's resource advertisement:

\begin{lstlisting}[language=yaml, caption={Advertisement CRD structure}, label={lst:advertisement-crd}]
apiVersion: rear.fluidos.eu/v1alpha1
kind: Advertisement
metadata:
  name: cluster-advertisement
  namespace: default
spec:
  clusterID: "cluster-a"
  timestamp: "2024-01-15T10:30:00Z"
  resources:
    allocatable:
      cpu: "100"
      memory: "200Gi"
    allocated:
      cpu: "40"
      memory: "80Gi"
    available:
      cpu: "60"
      memory: "120Gi"
  cost:
    amount: "0.05"
    currency: "USD"
    unit: "cpu-hour"
status:
  published: true
  lastPublishTime: "2024-01-15T10:30:05Z"
  message: "Advertisement published successfully"
\end{lstlisting}

Key design decisions:
\begin{itemize}
    \item \textbf{Single Advertisement per cluster}: Simplifies management
    \item \textbf{Timestamp in spec}: Enables staleness detection by broker
    \item \textbf{Separate allocated vs available}: Supports accurate accounting
    \item \textbf{Status tracks publishing}: Provides visibility into broker communication
\end{itemize}

\subsection{ClusterAdvertisement CRD (Resource Broker)}

The ClusterAdvertisement represents a remote cluster's resources from broker's perspective:

\begin{lstlisting}[language=yaml, caption={ClusterAdvertisement CRD structure}, label={lst:cluster-adv-crd}]
apiVersion: broker.fluidos.eu/v1alpha1
kind: ClusterAdvertisement
metadata:
  name: cluster-a-adv
  namespace: default
spec:
  clusterID: "cluster-a"
  timestamp: "2024-01-15T10:30:00Z"
  resources:
    allocatable:
      cpu: "100"
      memory: "200Gi"
    allocated:
      cpu: "40"
      memory: "80Gi"
    available:
      cpu: "60"
      memory: "120Gi"
    reserved:
      cpu: "10"
      memory: "20Gi"
  cost:
    amount: "0.05"
    currency: "USD"
    unit: "cpu-hour"
status:
  active: true
  phase: "Active"
  score: "0.85"
  lastUpdateTime: "2024-01-15T10:30:10Z"
  message: "Cluster is active and available"
\end{lstlisting}

Key design decisions:
\begin{itemize}
    \item \textbf{Reserved resources}: Tracks resources reserved but not yet allocated
    \item \textbf{Active status}: Indicates if advertisement is fresh (not stale)
    \item \textbf{Score in status}: Computed by decision engine, not user-provided
    \item \textbf{Phase field}: Human-readable state (Active, Stale)
\end{itemize}

\subsection{Reservation CRD (Resource Broker)}

The Reservation resource represents a workload placement request:

\begin{lstlisting}[language=yaml, caption={Reservation CRD structure}, label={lst:reservation-crd}]
apiVersion: broker.fluidos.eu/v1alpha1
kind: Reservation
metadata:
  name: workload-123
  namespace: default
spec:
  targetClusterID: ""  # Empty means auto-select
  requestedResources:
    cpu: "4"
    memory: "8Gi"
  requirements:
    maxCost: "0.10"
    preferredRegion: "us-west"
status:
  phase: "Pending"  # Pending, Reserved, Active, Failed, Completed
  selectedClusterID: ""
  reservationTime: ""
  message: ""
\end{lstlisting}

Key design decisions:
\begin{itemize}
    \item \textbf{Optional targetClusterID}: Allows manual or automatic cluster selection
    \item \textbf{Requirements section}: Extensible for future constraints
    \item \textbf{Phase-based lifecycle}: Clear state progression
\end{itemize}

\section{Resource Agent Design}
\label{sec:ra-design}

\subsection{Component Architecture}

The Resource Agent consists of three main components:

\begin{figure}[ht]
    \centering
    % TODO: Create Resource Agent component diagram
    % \includegraphics[width=0.8\textwidth]{figures/resource-agent-components.pdf}
    \caption{Resource Agent internal components}
    \label{fig:ra-components}
\end{figure}

\paragraph{Advertisement Controller}
\begin{itemize}
    \item Reconciles Advertisement resources
    \item Triggers metrics collection on changes
    \item Invokes publisher to send to broker
    \item Updates status with publish results
\end{itemize}

\paragraph{Metrics Collector}
\begin{itemize}
    \item Queries Kubernetes API for nodes and pods
    \item Filters nodes by readiness status
    \item Aggregates container resource requests
    \item Calculates allocatable, allocated, and available resources
\end{itemize}

\paragraph{Broker Publisher}
\begin{itemize}
    \item Creates dynamic Kubernetes client for broker cluster
    \item Creates or updates ClusterAdvertisement in broker
    \item Implements retry logic with exponential backoff
    \item Differentiates transient vs permanent errors
\end{itemize}

\subsection{Reconciliation Logic}

The Advertisement controller follows this reconciliation flow:

\begin{algorithm}
\caption{Advertisement Reconciliation}
\label{alg:ra-reconciliation}
\begin{algorithmic}[1]
\STATE Fetch Advertisement resource
\IF{Advertisement not found}
    \RETURN (no requeue)
\ENDIF
\STATE Collect cluster metrics using MetricsCollector
\STATE Update Advertisement.Spec with current metrics
\STATE Update Advertisement locally
\STATE published $\gets$ false
\IF{BrokerClient enabled}
    \STATE err $\gets$ BrokerClient.PublishAdvertisement()
    \IF{err $\neq$ nil}
        \STATE published $\gets$ false
        \STATE message $\gets$ "Local update successful, but publish failed"
    \ELSE
        \STATE published $\gets$ true
        \STATE message $\gets$ "Advertisement updated and published"
    \ENDIF
\ENDIF
\STATE Update Advertisement.Status with published flag and message
\RETURN (requeue after 30s)
\end{algorithmic}
\end{algorithm}

\subsection{Watch Strategy}

To minimize reconciliation overhead, the controller implements:

\begin{itemize}
    \item \textbf{Primary watch} on Advertisement resource
    \item \textbf{Secondary watch} on Pods (with special handling)
    \item \textbf{No-op handler} for pod events: Returns empty reconciliation requests
    \item \textbf{Periodic sync} every 30 seconds ensures freshness
\end{itemize}

This prevents reconciliation storms in clusters with thousands of pods constantly changing.

\subsection{Error Handling Strategy}

The publisher differentiates error types:

\begin{lstlisting}[language=Go, caption={Error differentiation}, label={lst:error-diff}]
func isTransientError(err error) bool {
    return apierrors.IsTimeout(err) ||
           apierrors.IsServerTimeout(err) ||
           apierrors.IsServiceUnavailable(err) ||
           apierrors.IsTooManyRequests(err) ||
           apierrors.IsInternalError(err)
}
\end{lstlisting}

\begin{itemize}
    \item \textbf{Transient errors}: Retry with exponential backoff (4 attempts)
    \item \textbf{Permanent errors}: Fail immediately (e.g., authentication, not found)
\end{itemize}

\section{Resource Broker Design}
\label{sec:rb-design}

\subsection{Component Architecture}

The Resource Broker consists of four main components:

\begin{figure}[ht]
    \centering
    % TODO: Create Resource Broker component diagram
    % \includegraphics[width=0.8\textwidth]{figures/resource-broker-components.pdf}
    \caption{Resource Broker internal components}
    \label{fig:rb-components}
\end{figure}

\paragraph{ClusterAdvertisement Controller}
\begin{itemize}
    \item Monitors ClusterAdvertisement resources
    \item Detects stale advertisements (>10 minutes old)
    \item Updates scores via decision engine
    \item Updates status fields (active, phase, score)
\end{itemize}

\paragraph{Reservation Controller}
\begin{itemize}
    \item Manages Reservation lifecycle
    \item Selects best cluster using decision engine
    \item Performs atomic reservation with retry
    \item Handles reservation cleanup and resource release
\end{itemize}

\paragraph{Decision Engine}
\begin{itemize}
    \item Implements cluster scoring algorithm
    \item Considers resource availability (70\% weight)
    \item Considers cost (30\% weight)
    \item Supports extensible scoring criteria
\end{itemize}

\paragraph{Resource Calculator}
\begin{itemize}
    \item Validates if cluster can satisfy reservation
    \item Atomically adds reservations to clusters
    \item Releases reservations with bounds checking
    \item Recalculates available resources
\end{itemize}

\subsection{Reservation Lifecycle}

Reservations progress through states:

\begin{figure}[ht]
    \centering
    % TODO: Create state machine diagram
    % \includegraphics[width=0.9\textwidth]{figures/reservation-states.pdf}
    \caption{Reservation state machine}
    \label{fig:reservation-states}
\end{figure}

\begin{enumerate}
    \item \textbf{Pending}: Initial state, awaiting cluster selection
    \item \textbf{Reserved}: Resources reserved in chosen cluster
    \item \textbf{Active}: Workload deployed (future work)
    \item \textbf{Completed}: Workload finished, resources released
    \item \textbf{Failed}: Reservation failed (no suitable cluster, timeout, etc.)
\end{enumerate}

\subsection{Decision Engine Algorithm}

The decision engine scores clusters based on two criteria:

\subsubsection{Resource-Based Scoring (70\% weight)}

\begin{equation}
\label{eq:resource-score}
S_{resource} = (1 - U_{cpu} \times 0.5) + (1 - U_{memory} \times 0.5)
\end{equation}

where utilization after reservation:

\begin{equation}
\label{eq:utilization}
U_{resource} = 1 - \frac{Available_{resource} - Requested_{resource}}{Allocatable_{resource}}
\end{equation}

This favors clusters with more headroom after reservation.

\subsubsection{Cost-Based Scoring (30\% weight)}

\begin{equation}
\label{eq:cost-score}
S_{cost} = \frac{1}{1 + Cost}
\end{equation}

Using inverse scaling ensures:
\begin{itemize}
    \item Cheaper clusters get higher scores
    \item Score remains bounded in $(0, 1]$
    \item Cost of 0 gives maximum score of 1
\end{itemize}

\subsubsection{Final Score}

\begin{equation}
\label{eq:final-score}
S_{final} = 0.7 \times S_{resource} + 0.3 \times S_{cost}
\end{equation}

The cluster with the highest final score is selected.

% TODO: Justify weight choices (70/30 split) or make them configurable

\subsection{Atomic Reservation Mechanism}

To prevent race conditions, we implement atomic reservations using optimistic locking:

\begin{algorithm}
\caption{Atomic Reservation with Retry}
\label{alg:atomic-reservation}
\begin{algorithmic}[1]
\STATE maxRetries $\gets$ 5
\FOR{attempt $\gets$ 0 to maxRetries}
    \STATE // Step 1: Fresh read to get latest resourceVersion
    \STATE clusterAdv $\gets$ Get(ClusterAdvertisement)
    \IF{clusterAdv not found}
        \RETURN error("Cluster not found")
    \ENDIF
    \STATE
    \STATE // Step 2: Check resource availability
    \IF{NOT CanReserve(clusterAdv, requestedCPU, requestedMemory)}
        \RETURN error("Insufficient resources")
    \ENDIF
    \STATE
    \STATE // Step 3: Add reservation (modifies in-memory copy)
    \STATE AddReservation(clusterAdv, requestedCPU, requestedMemory)
    \STATE
    \STATE // Step 4: Atomic update with resourceVersion check
    \STATE err $\gets$ Update(clusterAdv)
    \IF{err = nil}
        \RETURN success
    \ELSIF{IsConflict(err)}
        \STATE // Another client modified the resource, retry
        \STATE backoff $\gets$ 100ms $\times$ $2^{attempt}$
        \STATE sleep(backoff)
        \STATE continue
    \ELSE
        \RETURN err
    \ENDIF
\ENDFOR
\RETURN error("Failed after max retries")
\end{algorithmic}
\end{algorithm}

Key properties:
\begin{itemize}
    \item \textbf{Atomicity}: Read-check-modify-write is atomic via resourceVersion
    \item \textbf{Consistency}: Only one client succeeds if multiple attempt simultaneously
    \item \textbf{Retry logic}: Failed attempts retry with exponential backoff
    \item \textbf{Timeout}: Gives up after 5 attempts to prevent infinite loops
\end{itemize}

\section{Resource Accounting Model}
\label{sec:resource-accounting}

\subsection{Resource States}

We track resources in four states:

\begin{table}[ht]
\centering
\caption{Resource state definitions}
\label{tab:resource-states}
\begin{tabular}{@{}ll@{}}
\toprule
\textbf{State} & \textbf{Definition} \\ \midrule
Allocatable & Total resources usable for pods (Capacity - SystemReserved) \\
Allocated & Resources requested by running pods \\
Reserved & Resources reserved for pending workloads \\
Available & Allocatable - Allocated - Reserved \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Invariants}

The system maintains these invariants:

\begin{enumerate}
    \item $Available = Allocatable - Allocated - Reserved$
    \item $Available \geq 0$ (enforced by bounds checking)
    \item $Allocated + Reserved \leq Allocatable$
    \item Resource Agent controls $Allocatable$ and $Allocated$
    \item Resource Broker controls $Reserved$
\end{enumerate}

\subsection{Update Responsibilities}

\begin{table}[ht]
\centering
\caption{Resource update responsibilities}
\label{tab:update-responsibilities}
\begin{tabular}{@{}lll@{}}
\toprule
\textbf{Resource Field} & \textbf{Updated By} & \textbf{When} \\ \midrule
Allocatable & Resource Agent & Node capacity changes \\
Allocated & Resource Agent & Pods scheduled/terminated \\
Reserved & Resource Broker & Reservations created/released \\
Available & Both & Recalculated after updates \\ \bottomrule
\end{tabular}
\end{table}

\section{Communication Patterns}
\label{sec:communication}

\subsection{Agent-to-Broker Communication}

Resource Agents publish advertisements to the broker:

\begin{enumerate}
    \item Agent creates dynamic Kubernetes client for broker cluster
    \item Authenticates using service account token or kubeconfig
    \item Creates/updates ClusterAdvertisement resource
    \item Retries on transient failures with exponential backoff
\end{enumerate}

% TODO: Add sequence diagram
\begin{figure}[ht]
    \centering
    % \includegraphics[width=\textwidth]{figures/agent-broker-communication.pdf}
    \caption{Sequence diagram of Agent-Broker communication}
    \label{fig:agent-broker-seq}
\end{figure}

\subsection{Client-to-Broker Communication}

Workload requesters interact with the broker:

\begin{enumerate}
    \item Client creates Reservation resource in broker cluster
    \item Reservation controller reconciles and selects cluster
    \item Controller updates Reservation status with results
    \item Client polls status or uses watch API
\end{enumerate}

% TODO: Add sequence diagram
\begin{figure}[ht]
    \centering
    % \includegraphics[width=\textwidth]{figures/client-broker-communication.pdf}
    \caption{Sequence diagram of Client-Broker interaction}
    \label{fig:client-broker-seq}
\end{figure}

\section{Design Decisions and Trade-offs}
\label{sec:design-decisions}

\subsection{Centralized vs Distributed Broker}

\textbf{Decision}: Centralized broker

\textbf{Rationale}:
\begin{itemize}
    \item \textit{Pros}: Simpler to implement, global view of all clusters, easier debugging
    \item \textit{Cons}: Single point of failure, scalability bottleneck
\end{itemize}

We chose centralization for simplicity while enabling horizontal scaling of the broker deployment for high availability.

% TODO: Discuss if you implemented HA/multi-replica broker

\subsection{Push vs Pull Advertisement}

\textbf{Decision}: Push-based (Agents push to Broker)

\textbf{Rationale}:
\begin{itemize}
    \item Agents know when resources change
    \item Broker doesn't need credentials for all clusters
    \item Reduces security attack surface
    \item Easier firewall/network configuration
\end{itemize}

\subsection{Optimistic vs Pessimistic Locking}

\textbf{Decision}: Optimistic locking with retry

\textbf{Rationale}:
\begin{itemize}
    \item Kubernetes native approach (resourceVersion)
    \item Better performance under low contention
    \item No need for distributed lock manager
    \item Retry handles transient conflicts
\end{itemize}

\subsection{Scoring Weights}

\textbf{Decision}: 70\% resources, 30\% cost

\textbf{Rationale}:
\begin{itemize}
    \item Prioritizes resource availability to prevent failures
    \item Still considers cost for optimization
    \item Weights can be made configurable in future
\end{itemize}

% TODO: Add empirical justification if you experimented with different weights

\section{Scalability Considerations}
\label{sec:scalability}

\subsection{Agent Scalability}

Each agent operates independently:
\begin{itemize}
    \item No coordination between agents needed
    \item Agents can be deployed to hundreds of clusters
    \item Resource usage is O(nodes + pods) per agent
\end{itemize}

\subsection{Broker Scalability}

The broker handles:
\begin{itemize}
    \item O(clusters) ClusterAdvertisement resources
    \item O(reservations) active Reservation resources
    \item List operations for cluster selection: O(clusters)
\end{itemize}

Optimizations:
\begin{itemize}
    \item Client caching reduces API server load
    \item Stale advertisements marked inactive (not deleted)
    \item Periodic cleanup of completed reservations
\end{itemize}

% TODO: Add performance numbers if you have them (e.g., "supports 100 clusters with <1s latency")

\section{Summary}
\label{sec:design-summary}

This chapter presented the system design including:
\begin{itemize}
    \item Overall architecture with Resource Agent and Resource Broker
    \item Custom Resource Definitions for Advertisement, ClusterAdvertisement, and Reservation
    \item Component internals and reconciliation logic
    \item Decision engine with multi-criteria scoring
    \item Atomic reservation mechanism preventing race conditions
    \item Resource accounting model and communication patterns
\end{itemize}

The design balances simplicity, correctness, and performance while enabling future extensibility. The next chapter details the implementation of these design components.
